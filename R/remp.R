#' @title Repetitive element methylation prediction
#'
#' @description
#' \code{remp} is used to predict genomewide methylation levels of locus-specific repetitive elements (RE).
#' Two major RE types in human, Alu element (Alu) and LINE-1 (L1) are available.
#'
#' @param methyDat A \code{\link{RatioSet}}, \code{\link{GenomicRatioSet}}, \code{\link{DataFrame}}, 
#' \code{data.table}, \code{data.frame}, or \code{matrix} of methylation dataset. See Details.
#' @param REtype Type of RE. Currently \code{"Alu"} and \code{"L1"} are supported.
#' @param parcel An \code{\link{REMParcel}} object containing necessary data to carry out the
#' prediction. If \code{NULL}, the function will search the \code{.rds} data file in \code{work.dir} 
#' exported by \code{\link{initREMP}} (with \code{export = TRUE}) or \code{\link{saveParcel}}. 
#' @param work.dir Path to the directory where the annotation data generated by \code{\link{initREMP}} 
#' are saved. Valid when the argument \code{parcel} is missing. If not specified, temporary directory 
#' \code{tempdir()} will be used. If specified, the directory path has to be the same as the 
#' one specified in \code{\link{initREMP}} or in \code{\link{saveParcel}}.
#' @param groom Should the function run \code{\link{grooMethy}} implicitly to check and fix the data? 
#' Default = \code{TRUE}. If \code{\link{grooMethy}} has been run in advance, let \code{groom = FALSE} can 
#' avoid repeated check.
#' @param win An integer specifying window size to confine the upstream and downstream flanking 
#' region centered on the predicted CpG in RE for prediction. Default = \code{1000}. See Details.
#' @param method Name of model/approach for prediction. Currently \code{"rf"} (Random Forest),  
#' \code{"svmLinear"} (SVM with linear kernel), \code{"svmRadial"} (SVM with linear kernel), and
#' \code{"naive"} (carrying over methylation values of the closest CpG site) are available. 
#' Default = \code{"rf"} (Random Forest). See Details.
#' @param autoTune Logical parameter. If \code{TRUE}, a 3-time repeated 5-fold cross validation 
#' will be performed to determine the best model parameter. If \code{FALSE}, the \code{param} option 
#' (see below) must be specified. Default = \code{TRUE}. Auto-tune will be disabled using Random Forest. 
#' See Details.
#' @param param A number or a vector specifying the model tuning parameter(s) (not applicable for Random Forest).
#' For SVM, \code{param} represents 'Cost' (for linear kernel) or 'Sigma'
#' and 'Cost' (for radial basis function kernel). This parameter is valid only when \code{autoTune = FALSE}.
#' @param seed Random seed for Random Forest model for reproducible prediction results. 
#' Default is \code{NULL}, which generates a seed.
#' @param ncore Number of cores to run parallel computation. By default, max number of cores available 
#' in the machine will be utilized. If \code{ncore = 1}, no parallel computation is allowed.
#' @param BPPARAM An optional \code{\link{BiocParallelParam}} instance determining the parallel back-end to 
#' be used during evaluation. If not specified, default back-end in the machine will be used.
#' @param verbose Logical parameter. Should the function be verbose?
#' 
#' @details 
#' Before running \code{remp}, user should make sure the methylation data have gone through 
#' proper quality control, background correction, and normalization procedures. Both beta value
#' and M value are allowed. Rows represents probes and columns represents samples. Please make 
#' sure to have row names that specify the Illumina probe ID (i.e. cg00000029). Parameter 
#' \code{win = 1000} is based on previous findings showing that neighboring CpGs are more likely 
#' to be co-modified within 1000 bp. User can specify narrower window size for slight improvement of 
#' prediction accuracy at the cost of less predicted RE. Window size greater than 1000 is not
#' recommended as the machine learning models would not be able to learn much userful information 
#' for prediction but introduce noise. Random Forest model (\code{method = "rf"}) is recommented 
#' as it offers more accurate prediction and it also enables prediction reliability functionality. 
#' Prediction reliability is estimated by conditional standard deviation using Quantile Regression Forest. 
#' Please note that if parallel computing is allowed, parallel Random Forest 
#' (powered by package \code{\link{ranger}}) will be used automatically. The performance of 
#' Random Forest model is often relatively insensitive to the choice of \code{mtry}.
#' Therefore, auto-tune will be turned off using Random Forest and \code{mtry} will be set to one third 
#' of the total number of predictors. For SVM, if \code{autoTune = TRUE}, preset tuning parameter 
#' search grid can be access and modified using \code{\link{remp_options}}.
#' 
#' @return An \code{\link{REMProduct}} object containing prediction results.
#' 
#' @seealso See \code{\link{initREMP}} to prepare necessary annotation database before running \code{remp}.
#'
#' @examples
#' # Obtain example Illumina example data (450k)
#' GM12878_450k <- getGM12878('450k')
#' 
#' # Make sure you have run 'initREMP'. See ?initREMP.
#' 
#' # Run prediction (grooMethy will be run implicitly)
#' remp.res <- remp(GM12878_450k, REtype = 'Alu', ncore = 1)
#' remp.res
#' details(remp.res)
#' 
#' # Extract CpG location information (inherit from class 'RangedSummarizedExperiment')
#' rowRanges(remp.res) 
#' 
#' # RE annotation information
#' rempAnnot(remp.res)
#' 
#' # Add gene annotation
#' remp.res <- decodeAnnot(remp.res, type = "symbol", ncore = 1)
#' rempAnnot(remp.res)
#' 
#' # (Recommended) Trim off less reliable prediction
#' remp.res <- rempTrim(remp.res, threshold = 1.7, missingRate = 0.2)
#' 
#' # (Recommended) Obtain RE-level methylation (aggregate by mean)
#' remp.res <- rempAggregate(remp.res, NCpG = 2, ncore = 1)
#' 
#' # Extract RE location information 
#' rowRanges(remp.res)
#' 
#' # Density plot across predicted RE
#' plot(remp.res)
#' 
#' @export
remp <- function(methyDat, REtype = c("Alu", "L1"), parcel = NULL, 
                 work.dir = tempdir(), groom = TRUE,
                 win = 1000, method = c("rf", "svmLinear", "svmRadial", "naive"), 
                 autoTune = TRUE, param = NULL, seed = NULL, ncore = NULL, BPPARAM = NULL, 
                 verbose = FALSE) {
  t <- Sys.time()
  REtype <- match.arg(REtype)
  method <- match.arg(method)
  
  if(win > remp_options(".default.max.flankWindow"))
    stop("Flanking window size cannot be greater than ", remp_options(".default.max.flankWindow"), 
         ". Please see ?remp_options for details.")
  
  if (is.null(ncore)) 
    ncore <- parallel::detectCores()
  
  if(method == "rf")
  {
    if (is.null(seed))
      seed = sample(.Random.seed,1)
    message("Using random seed = ", seed)
    
    autoTune <- FALSE # No need to tune RF mtry
    param <- round(length(remp_options(".default.predictors"))/3) # one third of number of predictors
    if (verbose) 
      message("Note: Auto-tune is disabled for Random Forest and mtry is set to one third of number of predictors (", param, ").")
  }
  
  ## Setup backend for paralell computing
  be <- getBackend(ncore, BPPARAM, verbose)
  ncore <- BiocParallel::bpworkers(be)
  
  message("Start RE methylation prediction with ", BiocParallel::bpworkers(be), 
          " core(s) ...", .timeTrace(t))
  
  if (method != "naive" & !autoTune & is.null(param)) {
    message("Tuning parameter for method = '", method, "' is missing!")
    stop("You turned off auto-tune. Please specify parameter.")
  }
  
  ## Groom methylation data
  if(groom)
  {
    methyDat <- grooMethy(methyDat, verbose)
  }
  
  methyDat <- minfi::getM(methyDat)
  
  arrayType <- .guessArrayType(methyDat)
  if (verbose) 
    message("Illumina ", arrayType, " array detected.")
  
  subDirName <- paste0("REMP.data.", arrayType)
  work.dir <- .forwardSlashPath(work.dir)
  data.dir <- .forwardSlashPath(file.path(work.dir, subDirName))
  
  ## Get the REMParcel object ready
  
  if(is.null(parcel))
  {
    path_to_parcel <- file.path(data.dir, 
                                paste0("REMParcel_", 
                                       REtype, "_", 
                                       arrayType, "_", 
                                       remp_options(".default.max.flankWindow"), 
                                       ".rds"))
    
    if (file.exists(path_to_parcel)){
      remparcel <- readRDS(path_to_parcel)
    } else {
      stop("Necessary annotation data files are missing. Please make sure:
           1) you have run initREMP() first to generate the data. See ?initREMP for details; 
           2) your working directory specified is the same as you did in initREMP(); 
           3) the RE type and/or platform match the annotation data generated by initREMP().")
    }
  } else {
    .isREMParcelOrStop(parcel)
    remparcel <- parcel
  }
  
  refgene_main <- getRefGene(remparcel)
  RE_refGene.original <- getRE(remparcel)
  RE_CpG <- getRECpG(remparcel)
  ILMN <- getILMN(remparcel)
  RE_CpG_ILMN <- getILMN(remparcel, REonly = TRUE)
  
  ####
  
  samplenames <- colnames(methyDat)
  sampleN <- length(samplenames)
  
  ## Make indicator of genomic regions
  RE_refGene <- .toIndicator(RE_refGene.original)
  # ILMN <- .toIndicator(ILMN)
  
  ## RE.CpG : Add CpG density and rename
  ## identical(runValue(RE_refGene$Index), runValue(RE_CpG$Index))
  RE_refGene$N <- runLength(RE_CpG$Index)
  RE_refGene$Length <- width(RE_refGene)
  RE_refGene$CpG.density <- RE_refGene$N/RE_refGene$Length  #density of CpG within RE sequence
  
  merge_RE_CpG_meta <- mcols(RE_refGene)[match(as.character(RE_CpG$Index), 
                                               as.character(RE_refGene$Index)), ]
  merge_RE_CpG_meta$CpG.ID <- as.character(granges(RE_CpG))
  mcols(RE_CpG) <- setNames(merge_RE_CpG_meta, paste0("RE.", colnames(merge_RE_CpG_meta)))
  # all(as.character(granges(RE_CpG)) == RE_CpG$RE.CpG.ID)
  
  ## Find valid CpG sites with methylation profiled
  commonCpGIndex <- intersect(rownames(methyDat), ILMN$Index)
  
  ## Trim down methyDat:
  methyDat <- methyDat[match(commonCpGIndex, rownames(methyDat)), , drop = FALSE]
  
  ## ILMN : create pointer and rename. Note: Different Methy data will
  ## result in different size of this data!
  ILMN <- ILMN[match(commonCpGIndex, ILMN$Index), ]
  mcols(ILMN) <- setNames(mcols(ILMN), paste0("ILMN.", colnames(mcols(ILMN))))
  ILMN$Methy.ptr <- seq_len(length(ILMN))
  # identical(ILMN$ILMN.Index, rownames(methyDat))
  
  ## RE_CpG_ILMN : Compute total number of RE covered by ILMN. Note:
  ## Different Methy data will result in different size of this data.
  RE_CpG_ILMN <- RE_CpG_ILMN[RE_CpG_ILMN$Index %in% rownames(methyDat),]
  RE_CpG_ILMN <- unique(RE_CpG_ILMN)
  
  RE_CpG_ILMN_DATA <- methyDat[match(RE_CpG_ILMN$Index, rownames(methyDat)), , drop = FALSE]
  
  ############################################################# Find RE_CpG's neighboring CpG
  if (verbose) 
    message("Processing ", REtype, " with window +/- ", win, " base pair ...", .timeTrace(t))
  RE_CpG_flanking <- .twoWayFlank(granges(RE_CpG), win)
  HITS <- findOverlaps(RE_CpG_flanking, ILMN, ignore.strand = TRUE)
  
  ## Part 1: RE-CpG
  RE_NeibCpG <- RE_CpG[queryHits(HITS), ]
  ## Total RE that can be predicted (contains neighboring CpGs within
  ## given window)
  
  ## Part 2: Neighboring ILMN CpG
  RE_NeibCpG_ILMN <- ILMN[subjectHits(HITS), ]
  RE_NeibCpG_ILMN <- DataFrame(RE_NeibCpG_ILMN.GR = granges(RE_NeibCpG_ILMN), 
                               mcols(RE_NeibCpG_ILMN))
  mcols(RE_NeibCpG) <- DataFrame(mcols(RE_NeibCpG), RE_NeibCpG_ILMN)
  # identical(as.character(granges(RE_NeibCpG)), RE_NeibCpG$RE.CpG.ID)
  
  ## Remove singleton (RE-CpGs with only one neighboring ILMN CpG)
  message("Preparing neighboring CpG information ...", .timeTrace(t))
  RE_NeibCpG$distance <- abs(start(RE_NeibCpG$RE_NeibCpG_ILMN.GR) - start(RE_NeibCpG))
  RE_NeibCpG <- RE_NeibCpG[RE_NeibCpG$distance > 1,]
  
  ## Add core predictors.
  RE_NeibCpG <- RE_NeibCpG[order(RE_NeibCpG$RE.CpG.ID, RE_NeibCpG$distance), ]
  RE_NeibCpG.DF <- mcols(RE_NeibCpG)[, c("RE.CpG.ID", "Methy.ptr", "distance")]
  
  distance_agg <- .aggregateNeib(distance ~ RE.CpG.ID, RE_NeibCpG.DF, 
                                 function(x) c(length(x), mean(x), sd(x), x[1], x[2]), 
                                 c("RE.CpG.ID", "N.nbr", "distance.mean", 
                                   "distance.std", "distance.min", "distance.min2"))
  Methy_ptr_agg <- .aggregateNeib(Methy.ptr ~ RE.CpG.ID, RE_NeibCpG.DF, 
                                  function(x) c(x[1], x[2]), 
                                  c("RE.CpG.ID", "Methy.ptr.min", "Methy.ptr.min2"))
  
  Methy_ptr_distance_agg <- merge(distance_agg, Methy_ptr_agg, by = "RE.CpG.ID")
  
  RE_NeibCpG_meta <- mcols(RE_NeibCpG)
  mcols(RE_NeibCpG) <- cbind(RE_NeibCpG_meta, 
                             Methy_ptr_distance_agg[match(RE_NeibCpG_meta$RE.CpG.ID, 
                                                          Methy_ptr_distance_agg$RE.CpG.ID), -1])
  RE_NeibCpG <- RE_NeibCpG[order(RE_NeibCpG$RE.Index)]
  RE_NeibCpG <- RE_NeibCpG[RE_NeibCpG$N.nbr > 1, ]  ## Remove singleton
  
  if (verbose) 
    message("Template generation completed ...", .timeTrace(t))
  
  ####################################### 
  
  if ("naive" == method) {
    BEST_TUNE <- DataFrame(matrix(NA, ncol = sampleN, nrow = 1)) 
    colnames(BEST_TUNE) <- "Not_Applicable"
    libToLoad <- NULL
    method_text <- "Naive (nearest CpG)"
    QCname_text <- "N/A"
  }
  if ("rf" == method) {
    BEST_TUNE <- DataFrame(matrix(NA, nrow = sampleN, ncol = 1))
    colnames(BEST_TUNE) <- "mtry"
    libToLoad <- NULL
    method_text <- "Random Forest"
    QCname_text <- "Quantile Regression Forest"
  }
  if ("svmLinear" == method) {
    BEST_TUNE <- DataFrame(matrix(NA, nrow = sampleN, ncol = 1))
    colnames(BEST_TUNE) <- "Cost"
    libToLoad <- "kernlab"
    method_text <- "SVM(Linear)"
    QCname_text <- "N/A"
  }
  if ("svmRadial" == method) {
    BEST_TUNE <- DataFrame(matrix(NA, nrow = sampleN, ncol = 2)) 
    colnames(BEST_TUNE) <- c("gamma", "Cost")
    libToLoad <- "kernlab"
    method_text <- "SVM(Radial)"
    QCname_text <- "N/A"
  }
  rownames(BEST_TUNE) <- samplenames
  
  if (verbose) 
    message("Prediction model: ", method_text, "\nQC model: ", QCname_text)
  
  cpgRanges <- unique(RE_NeibCpG[, "RE.Index"])
  RE_annotation <- subsetByOverlaps(RE_refGene.original, cpgRanges) 
  # Note: Some REs have overlapping regions thus there can be more than one REs mapped to one RE-CpG.
  RE_annotation_name <- colnames(mcols(RE_annotation))
  regionCode <- mcols(RE_annotation)[remp_options(".default.genomicRegionColNames")]
  RE_annotation <- RE_annotation[, RE_annotation_name[!RE_annotation_name %in% 
                                                        remp_options(".default.genomicRegionColNames")]]
  
  # Initiate container
  REMP_PREDICT_CpG <- matrix(NA, nrow = length(cpgRanges), ncol = sampleN)
  REMP_PREDICT_QC <- matrix(NA, nrow = length(cpgRanges), ncol = sampleN)
  REMP_PREDICT_IMP <- setNames(DataFrame(matrix(NA, nrow = length(remp_options(".default.predictors")), 
                                                ncol = sampleN)), samplenames)
  rownames(REMP_PREDICT_IMP) <- remp_options(".default.predictors")
  
  ## RE coverage
  RE_COVERAGE <- .coverageStats_RE(RE_annotation, regionCode, cpgRanges, RE_CpG_ILMN, 
                                   REtype, indent = "    ", verbose)
  
  # Gene coverage
  GENE_COVERAGE <- .coverageStats_GENE(regionCode, refgene_main, 
                                       REtype, indent = "    ", verbose)
  
  ## Prediction
  for (i in seq_len(sampleN)) {
    message("Predicting sample ", samplenames[i], " ...", .timeTrace(t))
    RE_CpG_ILMN_OneMethyDat <- RE_CpG_ILMN_DATA[, samplenames[i]]
    # identical(RE_CpG_ILMN$Index, names(RE_CpG_ILMN_OneMethyDat))
    
    ### To be predicted
    RE_unprf_neib <- .loadMethy(methyDat[, i, drop = FALSE], RE_NeibCpG)
    # summary(RE_unprf_neib$distance)
    
    ### For model training
    RE_unprf_neib <- unique(RE_unprf_neib[, c("RE.Index", remp_options(".default.predictors"))])
    HITS <- findOverlaps(RE_unprf_neib, RE_CpG_ILMN, ignore.strand = TRUE)
    RE_prf_neib <- RE_unprf_neib[queryHits(HITS), ]
    RE_prf_neib$Methy <- RE_CpG_ILMN_OneMethyDat[subjectHits(HITS)]
    # summary(RE_prf_neib$distance.min2) 
    # cor(RE_prf_neib$Methy.min, RE_prf_neib$Methy)
    
    P_basic <- .modelTrain(RE_prf_neib, remp_options(".default.predictors"), method, 
                           autoTune, param, be, seed, verbose)
    
    best_tune <- as.numeric(P_basic$bestTune)
    
    if (method != "naive") {
      REMP_PREDICT_IMP[, i] <- P_basic$importance$Overall
      for(k in seq_len(length(best_tune)))
      {
        BEST_TUNE[i, k] <- best_tune[k]
      }
    }
    
    ##############################################################################################
    
    newdata <- as.matrix(mcols(RE_unprf_neib)[, remp_options(".default.predictors")])

    if (method != "rf") {
      if (ncore > 1)
      {
        BiocParallel::bpstart(be)
        .bploadLibraryQuiet(libToLoad, be)
        ITER <- .iblkrow(newdata, chunks = ncore)
        REMP_PREDICT_CpG[, i] <- BiocParallel::bpiterate(ITER, .predictREMP, 
                                                         model = P_basic$model, 
                                                         BPPARAM = be, 
                                                         REDUCE = c, 
                                                         reduce.in.order = TRUE)
        BiocParallel::bpstop(be)
      } else {
        REMP_PREDICT_CpG[, i] <- .predictREMP(newdata, P_basic$model)
      } 
      REMP_PREDICT_QC <- NULL
    } else {
      REMP_PREDICT_CpG[, i] <- predict(P_basic$model, newdata, type = "response", 
                                       num.threads = ncore)$predictions
      REMP_PREDICT_QC[, i] <- .QTF(rangerObj = P_basic$model, 
                                   x = as.matrix(mcols(RE_prf_neib)[, remp_options(".default.predictors")]),
                                   y = as.numeric(mcols(RE_prf_neib)[, "Methy"]),
                                   newX = newdata, 
                                   seed = seed, 
                                   num.threads = ncore)
    }

    message("    ", samplenames[i], " completed! ", sampleN - i, 
            " sample(s) left ...", .timeTrace(t))
  }
  
  message("Done.", .timeTrace(t))
  
  remproduct <- REMProduct(REtype = REtype, platform = arrayType, win = as.character(win),
                           predictModel = method_text, QCModel = QCname_text, 
                           rempM = REMP_PREDICT_CpG, rempQC = REMP_PREDICT_QC,
                           cpgRanges = cpgRanges, sampleInfo = BEST_TUNE,
                           REannotation = RE_annotation, 
                           RECpG = RE_CpG_ILMN,
                           regionCode = regionCode,
                           refGene = refgene_main,
                           varImp = REMP_PREDICT_IMP, 
                           REStats = RE_COVERAGE, GeneStats = GENE_COVERAGE,
                           Seed = seed)
  return(remproduct)
  }  ## End of remp

## Internal functions
.toIndicator <- function(object) {
  genomicRegionInd <- matrix(0L, nrow = length(object), 
                             ncol = length(remp_options(".default.genomicRegionColNames")))
  genomicRegionInd[!is.na(mcols(object)[, remp_options(".default.genomicRegionColNames")])] <- 1L
  genomicRegionInd <- DataFrame(genomicRegionInd)
  colnames(genomicRegionInd) <- remp_options(".default.genomicRegionColNames")
  mcols(object)[, remp_options(".default.genomicRegionColNames")] <- genomicRegionInd
  return(object)
}

.loadMethy <- function(methyDatOne, RE_NeibCpG) {
  RE_NeibCpG$Methy.all <- methyDatOne[RE_NeibCpG$Methy.ptr, ]
  RE_NeibCpG$Methy.min <- methyDatOne[RE_NeibCpG$Methy.ptr.min, ]
  RE_NeibCpG$Methy.min2 <- methyDatOne[RE_NeibCpG$Methy.ptr.min2, ]
  
  RE_NeibCpG.DF <- mcols(RE_NeibCpG)[, c("RE.CpG.ID", "Methy.all")]
  Methy_all_agg <- .aggregateNeib(Methy.all ~ RE.CpG.ID, RE_NeibCpG.DF, 
                                  function(x) c(mean(x), sd(x)), 
                                  c("RE.CpG.ID", "Methy.mean", "Methy.std"))
  
  RE_NeibCpG_meta <- mcols(RE_NeibCpG)
  mcols(RE_NeibCpG) <- cbind(RE_NeibCpG_meta, 
                             Methy_all_agg[match(RE_NeibCpG_meta$RE.CpG.ID,
                                                 Methy_all_agg$RE.CpG.ID), -1])
  return(RE_NeibCpG)
}

.aggregateNeib <- function(relation, d, FUN, newColNames) {
  d_agg <- aggregate(relation, data = d, FUN)
  d_agg <- DataFrame(d_agg[, 1], DataFrame(d_agg[, -1]))
  return(setNames(d_agg, newColNames))
}

.modelTrain <- function(d, varname, method, autoTune, param, 
                        be, seed, verbose) {
  ncore <- BiocParallel::bpworkers(be)
  
  d <- as.data.frame(mcols(d)[, c("Methy", varname)])
  
  if (method == "naive") {
    modelFit <- list(model = NULL, QC = NULL, importance = NULL, bestTune = NULL, 
                     name = "naive")
  } else {
    
    # set up the tuning grid
    if (method == "svmLinear") {
      if (autoTune) {
        C <- remp_options(".default.C.svmLinear.tune")
      } else {
        C <- param
      }
      grid <- expand.grid(C = C)
      text <- "Cost"
    }
    
    if (method == "svmRadial") {
      if (autoTune) {
        sigma <- remp_options(".default.sigma.svmRadial.tune")
        C <- remp_options(".default.C.svmRadial.tune")
      } else {
        sigma <- param[1]
        C <- param[2]
      }
      grid <- expand.grid(sigma = sigma, C = C)
      text <- c("gamma", "cost")
    }
    
    if (autoTune) {
      trC.method <- "repeatedcv"
      trC.number <- 5
      trC.repeats <- 3
    } else {
      trC.method <- "none"
      trC.number <- 1
      trC.repeats <- NA
    }
    
    if (method == "rf") {
      text <- "mtry"
      doQC <- TRUE
      model.tune <- ranger::ranger(Methy ~ ., data = d, mtry = param, num.threads = ncore,
                                   importance = "permutation", keep.inbag = FALSE,
                                   scale.permutation.importance = TRUE, seed = seed)
      var_imp <- ranger::importance(model.tune)
      var_imp <- data.frame(Predictor = names(var_imp), 
                            Overall = var_imp)
      best_param <- model.tune$mtry
      model <- model.tune
    } else {
      set.seed(seed)
      if (ncore > 1) {
        trC <- caret::trainControl(method = trC.method, number = trC.number, 
                                   repeats = trC.repeats, allowParallel = TRUE)
        cluster <- parallel::makeCluster(ncore)
        doParallel::registerDoParallel(cluster)
        model.tune <- caret::train(Methy ~ ., data = d, method = method, 
                                   tuneGrid = grid, trControl = trC, importance = TRUE)
        parallel::stopCluster(cluster)
        registerDoSEQ()
      } else {
        trC <- caret::trainControl(method = trC.method, number = trC.number, 
                                   repeats = trC.repeats, allowParallel = FALSE)
        model.tune <- caret::train(Methy ~ ., data = d, method = method, 
                                   tuneGrid = grid, trControl = trC, importance = TRUE)
      }
      
      var_imp <- caret::varImp(model.tune)
      var_imp <- data.frame(Predictor = rownames(var_imp$importance), 
                            Overall = var_imp$importance)
      best_param <- model.tune$bestTune
      model = model.tune$finalModel
    }
    
    if (autoTune) {
      if (verbose) 
        message("    Best tuning parameter found: ", 
                paste(paste(text, unlist(best_param), sep = " = "), collapse = ", "))
    } else {
      if (verbose) 
        message("    Pre-specified tuning parameter: ", 
                paste(paste(text, unlist(best_param), sep = " = "), collapse = ", "))
    }
    modelFit <- list(model = model, 
                     importance = var_imp, 
                     bestTune = best_param, 
                     name = method)
  }
  return(modelFit)
}

# Prediction reliability based on Quantile random forest
.QTF <- function(rangerObj, x, y, newX, seed, num.threads)
{
  nodesX <- predict(rangerObj, x, num.threads = num.threads, 
                    type = "terminalNodes")$predictions
  nnodes <- max(nodesX)
  ntree <- ncol(nodesX)
  n <- nrow(x)
  valuesNodes  <- matrix(nrow=nnodes,ncol=ntree)
  
  set.seed(seed)
  for (tree in 1:ntree){
    shuffledNodes <- nodesX[rank(ind <- sample(1:n,n)),tree]
    useNodes <- sort(unique(as.numeric(shuffledNodes)))
    valuesNodes[useNodes,tree] <- y[ind[match(useNodes,shuffledNodes )]]
  }
  
  predictNodes <- predict(rangerObj, newX, num.threads, 
                          type = "terminalNodes")$predictions
  valuesPredict <- 0*predictNodes
  for (tree in 1:ntree){
    valuesPredict[,tree] <- valuesNodes[ predictNodes[,tree],tree]
  }
  result <- apply(valuesPredict,1,sd)
  return(result)
}

.predictREMP <- function(newdata, model) {
  if (is.null(model)) {
    data.frame(newdata)$Methy.min #newdata is matrix
  } else {
    if(any(class(model) %in% c("ksvm","vm"))) kernlab::predict(model, newdata) #kernlab has its own predict function
  }
}

# Count the number of RE by gene type (NM/NR/Total), used by
# .coverageStats_RE()
.countREByGene <- function(RE_annotation, RE_list) {
  Total <- length(RE_annotation)
  RE_annotation_sub <- RE_annotation[RE_annotation$Index %in% RE_list]
  NM <- sum(!is.na(RE_annotation_sub$InNM))
  NR <- sum(!is.na(RE_annotation_sub$InNR))
  Gene <- sum(!is.na(RE_annotation_sub$InNM) | !is.na(RE_annotation_sub$InNR))
  Intergenic <- sum(is.na(RE_annotation_sub$InNM) & is.na(RE_annotation_sub$InNR))
  
  return(c(Total = Total, NM = NM, NR = NR, Gene = Gene, Intergenic = Intergenic))
}

.coverageStats_RE <- function(RE_annotation, regionCode, cpgRanges, RE_CpG_ILMN, 
                              REtype, indent, verbose) {
  
  mcols(RE_annotation) <- cbind(mcols(RE_annotation), regionCode)
  mcols(cpgRanges) <- mcols(RE_annotation[match(cpgRanges$RE.Index, RE_annotation$Index)])
  
  RE_annotation_prf <- subsetByOverlaps(RE_annotation, RE_CpG_ILMN, ignore.strand = TRUE)
  cpgRanges_prf <- subsetByOverlaps(cpgRanges, RE_CpG_ILMN, ignore.strand = TRUE)
  
  # Profiled RE for prediction
  cvr_RE_win_list <- runValue(RE_annotation_prf$Index)
  
  # Profiled RE for prediction + predicted unprofiled RE
  cvr_unRE_win_list <- runValue(RE_annotation$Index)
  
  REStats <- DataFrame(cbind(.countREByGene(RE_annotation_prf, cvr_RE_win_list),
                             .countREByGene(cpgRanges_prf, cvr_RE_win_list),
                             .countREByGene(RE_annotation, cvr_unRE_win_list),
                             .countREByGene(cpgRanges, cvr_unRE_win_list)
  ))
  
  colnames(REStats) <- c("Trained_RE", "Trained_RECpG", "Predict_RE", "Predict_RECpG")
  
  if (verbose) {
    .showREStats(REStats, REtype, "message", indent, TRUE)
  }
  
  return(REStats)
}

# Count the number of genes covered by RE, used by
# .coverageStats_GENE()
.countCoveredGene <- function(regionCode, refgene_main) {
  InNM <- na.omit(regionCode$InNM)
  InNR <- na.omit(regionCode$InNR)
  
  NM_ind <- as.numeric(unique(unlist(strsplit(InNM, "[|]"))))
  NR_ind <- as.numeric(unique(unlist(strsplit(InNR, "[|]"))))
  gene_ind <- c(NM_ind, NR_ind)
  
  NM <- length(unique(refgene_main$GeneSymbol[NM_ind]))
  NR <- length(unique(refgene_main$GeneSymbol[NR_ind]))
  Gene <- length(unique(refgene_main$GeneSymbol[gene_ind]))
  
  return(c(NM = NM, NR = NR, Gene = Gene))
}

.coverageStats_GENE <- function(regionCode, refgene_main, 
                                REtype, indent, verbose) {
  ## Count the total number of gene (protein coding gene and noncoding RNA
  ## gene)
  totgene <- length(unique(refgene_main$GeneSymbol))
  totgene_NM <- length(unique(refgene_main[refgene_main$type == "NM",]$GeneSymbol))
  totgene_NR <- length(unique(refgene_main[refgene_main$type == "NR",]$GeneSymbol))
  
  GeneStats <- DataFrame(rbind(c(totgene_NM, totgene_NR, totgene), 
                               .countCoveredGene(regionCode, refgene_main)))
  
  rownames(GeneStats) <- c("Total", "Predicted RE")
  
  if (verbose) {
    .showGeneStats(GeneStats, REtype, "message", indent)
  }
  
  return(GeneStats)
}
